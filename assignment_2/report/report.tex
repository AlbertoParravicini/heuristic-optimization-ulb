\documentclass[
12pt,
a4paper,
oneside,
headinclude,
footinclude]{article}

\usepackage[table,xcdraw,svgnames, dvipsnames]{xcolor}
\usepackage[capposition=bottom]{floatrow}
\usepackage[colorlinks]{hyperref} % to add hyperlinks
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{csquotes}
\usepackage{amsmath} % For the big bracket
\usepackage[export]{adjustbox}[2011/08/13]
% \usepackage{subfig}
\usepackage{array}
\usepackage{url}
\usepackage{graphicx} % to insert images
\usepackage{titlepic} % to insert image on front page
\usepackage{geometry} % to define margin
\usepackage{listings} % to add code
\usepackage{caption}
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[utf8]{inputenc} % Required for including letters with accents
\usepackage{color}
\usepackage{subcaption}
\usepackage[nochapters, dottedtoc]{classicthesis}
\usepackage{listings} % For Python code

\usepackage[ruled]{algorithm2e} % For pseudo-code

\usepackage{mathpazo}

\usepackage{amsthm} % For definitions and theorems

\theoremstyle{definition} % Define the style of definitions
\newtheorem{definition}{Definition}[section]


\usepackage{lipsum} % For testing
\usepackage{color}

\usepackage{etoolbox}

\usepackage{bm} % For bold math

\usepackage{setspace}
\usepackage{minted}

% For tables
\usepackage{amssymb}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\definecolor{webbrown}{rgb}{.6,0,0}

\usepackage{titlesec} % to customize titles
\titleformat{\chapter}{\normalfont\huge}{\textbf{\thechapter.}}{20pt}{\huge\textbf}[\vspace{2ex}\titlerule] % to customize chapter title aspect
\titleformat{\section} % to customize section titles
{\fontsize{14}{15}\bfseries}{\thesection}{1em}{}

\titlespacing*{\chapter}{0pt}{-50pt}{20pt} % to customize chapter title space

\graphicspath{ {./figures/} } % images folder
\parindent0pt \parskip10pt % make block paragraphs
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm,headheight=3cm,headsep=3cm,footskip=1cm} % define margin
\hyphenation{Fortran hy-phen-ation}

\AtBeginDocument{%
	\hypersetup{
		colorlinks=true, breaklinks=true, bookmarks=true,
		urlcolor=webbrown, citecolor=Black, linkcolor=Black% Link colors
}}


\pagestyle{plain}
\title{\textbf{Heuristic Optimization \\ Implementation Exercise 1}}
\author{{Alberto Parravicini}}
\date{}	% default \today



% ====================================================
% =============================================== BEGIN
% ====================================================


\begin{document}

\maketitle
\pagenumbering{roman}
\setcounter{page}{1}





% ====================================================
% =============================================== COMPILATION
% ====================================================

\section{How to compile and run the code}
\subsection{\textbf{Prerequisites}}
\begin{itemize}
    \item \textbf{Cmake}, \textbf{make}, a \textbf{C++11} compiler.
    \item \textbf{Armadillo}, a linear algebra library. How to install it:\\
        \-\quad\texttt{sudo apt-get install liblapack-dev}\\
        \-\quad\texttt{sudo apt-get install libblas-dev}\\
        \-\quad\texttt{sudo apt-get install libboost-dev}\\
        
        \quad\texttt{sudo apt-get install libarmadillo-dev}
\end{itemize}
\subsection{\textbf{Compilation}}
\begin{itemize}
   \item Move to the \textit{build} folder (delete its content if it's not empty)\\
    \-\quad\texttt{cd build}
   \item Run \textit{cmake}\\
    \-\quad\texttt{cmake ../src}
   \item Run \textit{make}\\
    \-\quad\texttt{make}
\end{itemize}

The executable will be located in the \textit{build} folder, and is called \textbf{flowshop}.

\newpage
\subsection{\textbf{How to run the program}}
The generic syntax to run the program is\\
\-\quad\texttt{./flowshop} \\
\-\quad\quad\texttt{-{}-filename ../instances/instance\_name} \\
\-\quad\quad\texttt{-{}-algorithm [ii|vnd]} \\
\-\quad\quad\texttt{-{}-random\_seed 42} \\
\-\quad\quad\texttt{-{}-neighbourhood\_function [t|e|i]} \\
\-\quad\quad\texttt{-{}-initial\_state\_function [random|rz]} \\
\-\quad\quad\texttt{-{}-use\_best\_improvement [0|1]} \\
\-\quad\quad\texttt{-{}-neigh\_vector [tei|tie]} \\


\begin{itemize}
    \item \texttt{-{}-filename}, \texttt{-f}: path to the instance file to be used.
    \item \texttt{-{}-algorithm}, \texttt{-a}: algorithm to be used, either \textbf{ii}, \textit{Iterative improvement} (default), or \textbf{vnd}, \textit{Variable neighbour descent}.
    \item \texttt{-{}-random\_seed}, \texttt{-r}: integer number, used as seed for random number generation by the program. If omitted, the seed is randomized.
    \item \texttt{-{}-neighbourhood\_function}, \texttt{-n}: how the neighbours of a given candidate solution are computed, either \textbf{t}, \textit{Transpose} (default), \textbf{e}, \textit{Exchange}, or \textbf{i}, \textit{Insert}.
    \item \texttt{-{}-initial\_state\_function}, \texttt{-i}: how the initial candidate solution is computed, either \textbf{random}, \textit{randomly}, or \textbf{rz}, using the \textit{Simplified RZ heuristic} (default).
    \item \texttt{-{}-use\_best\_improvement}, \texttt{-b}: either \textbf{0} or \textbf{1} (default), set if the \textit{iterative improvement} algorithm should use \textit{First improvement} or \textit{Best improvement}. Ignored if the algorithm is set to \textbf{vnd}.
    \item \texttt{-{}-neigh\_vector}, \texttt{-v}: set the sequence of neighbourhood functions to be used by the \textbf{vnd} algorithm, either \textbf{tei}, \textit{Transpose, Exchange, Insert} (default) or \textbf{tie}, \textit{Transpose, Insert, Exchange}. Ignored if the algorithm is set to \textbf{ii}.
\end{itemize}

Example:\\
\quad\texttt{./flowshop -f ../instances/50\_20\_10 -a ii -{}-use\_best\_improvement=1 -i rz}

The algorithm will solve the instance \textbf{50\_20\_10} using \textit{Best improvement iterative search}, with a random seed, \textit{Transpose} neighbour function, and \textit{RZ heuristic}.




% ====================================================
% =============================================== PFSP
% ====================================================


\newpage
\section{Introduction to the PFSP}
In the \textit{Permutation Flow Shop Scheduling} (\textbf{PFSP}) we are given:
\begin{itemize}
    \item A set of $n$ jobs $J_1,\ \ldots,\ J_n$.
    \item A set of $m$ machines $M_1\ \ldots,\ M_m$.
    \item Each job $J_i$ is composed of $m$ different steps, $o_{i1},\ \ldots,\ o_{im}$, and each step must be executed on a different machine.
    \item Each step $o_{ij}$ has a processing time $p_{ij}$ associated to it.
    \item All jobs pass through the machines in the same order.
    \item A machine can process at most $1$ job at a time.
    \item Each job has a weight $w_i$ associated to it, which represents its importance.
\end{itemize}

Assume that the jobs run in the order $j_1,\ \ldots,\ j_n$, and go through the machines in order $M_1,\ \ldots,\ M_m$.
The completion time of the $i$th operation of job $j_k$ will be given by

\[
    C_{i,j_k}=
        \begin{cases}
        \sum_{l=i}^{i}{p_{l,j_1}} & if\ j_k = j_1\ \text{(first job)} \\
        \sum_{l=1}^{k}{p_{1,j_l}} & if\ i = 1\ \text{(first machine)} \\
        max(C_{i-1, j_k}, C_{i, j_{k-1}}) + p_{i,j_k} & \text{otherwise}
        \end{cases}
\]

In short, the completion time of the first job will be given by the sum of the processing times of each of its steps (as $j_1$ will always find all the machines available).\\
Also, a new job can be processed by the first machine as soon as this is available, hence the second condition.

Our goal is to find the optimal scheduling for the jobs, such that the \textbf{weighted completion time} is minimized.

$$min\ WCT = \sum_{i=1}^n{w_i \cdot C_{m, j_i}}$$




% ====================================================
% =============================================== IMPLEMENTATION
% ====================================================


\newpage
\section{Implementation}
This section will focus on the \textbf{C++} implementation of algorithms to solve \textbf{PFSP}. \\
For each class/file, it is provided a brief description.

$\bullet$ \texttt{flowshop.cpp}:\\
main access point to the implementation. The input arguments are handled using \textbf{Cxxopts} (\href{https://github.com/jarro2783/cxxopts}{https://github.com/jarro2783/cxxopts}), which provides GNU-style syntax for the input arguments.\\
It will also measure the execution time, and write the output to a file.

The central idea of the optimization algorithms implementation is to create a structure which allows the algorithms to operate transparently to the problem they are solving.\\
In order to do so, the implementation of the problem instance and of the candidate solutions are wrapped into appropriate classes, which expose to the optimization algorithm a set of functions what work transparently to the underlying implementation of the algorithm.

Even though this architecture can look rather complex, and potentially slow down the optimization process, it is also very versatile and can be extended to any sort of optimization or search problem that can be solved by \textit{local search}
algorithms.

$\bullet$ \texttt{pfsp\_state.h, pfsp\_state.cpp}: \\
The \textit{candidate solutions} (also referred to as \textit{states}) are wrapped into a class which allows the optimization algorithms to process the candidates solutions independently from their actual implementation.\\
The class can also store the value of the state, given by some evaluation function.\\
This could be useful, for example, if we had to store states in a priority queue sorted according to the state value.

$\bullet$ \texttt{pfps\_problem.h, pfsp\_problem.cpp}:\\
This class works as a wrapper to the actual problem instance. \\
A \textit{problem} is modelled as an entity having an initial state, an evaluation function which can be applied to the states, and a function to compute the neighbourhood of a given state. \\
All these functions are actually function pointers, and their implementations can be set at runtime when the problem is instantiated, or even after, if one wants to dynamically update the evaluation function that is being used (as in \textit{dynamic search}), or update how neighbours are generated (as in \textit{variable neighbourhood descent}).

$\bullet$ \texttt{support\_function.h, support\_function.cpp}: \\
this file provides a series of functions that are used by the optimization algorithms.
These functions are passed as input to the optimization algorithms by using function pointers. \\
This provide higher flexibility, and makes the algorithms transparent to how candidates solutions are evaluated or generated.

The evaluation function is decomposed in 2 parts: one is exposed to the optimization algorithm, and has a signature which is independent to the problem which is being solved; the other takes as input some parameters specific to an instance; this was done so that the \textbf{RZ heuristic} can evaluate partial solutions by re-using the existing code. 

\textbf{Armadillo} provides easy-to-use data-structures for matrices and vectors, with a syntax close to \textit{MATLAB}.\\
This allows for easy manipulations of vectors, and very efficient vectorized operations.

The 3 functions to generate the neighbours of a given candidate solution will return a vector of candidate solutions, which can be inspected by the optimization algorithm.\\
The functions that compute the initial candidate solution are also provided here. 
They take a problem instance as input, and output a candidate solution.\\
It should be noted that all the neighbours of a given state are generated, and they are evaluated only later.\\
Evaluating them straight away would improve the performances of \textit{Iterative Improvement}: however it will be shown later that the speed-up are very small, if the algorithm is combined with the \textit{RZ heuristic} (which is what would be done in a real-case usage).

$\bullet$ \texttt{engine.h, engine.cpp}:\\
abstractm implementation of an optimization engine, it contains a reference to a \textit{problem} to be optimized, and a virtual function to perform the search.\\
It also holds the optimal solution found by the search, and its score.

$\bullet$ \texttt{ii\_engine.h, ii\_engine.cpp}:\\
this class holds the implementation of the \textbf{iterative improvement} algorithm.\\
The constructor allows to choose between using \textit{first} or \textit{best} improvement, and to specify a \textit{problem} to be solved, or optimized.
The result of the search will be stored inside the class, and accessible to the outside.\\
It is important to note that the algorithm doesn't directly know how the problem instances or the candidate solutions are implemented, and as such the implementation is very flexible and easily extendible to other problems.

$\bullet$ \texttt{vnd\_engine.h, vnd\_engine.cpp}:
this class holds the implementation of the \textbf{variable neighbourhood descent} algorithm (\textit{VND}).\\
The structure of the class is similar to the one of iterative improvement.\\
In the case of \textit{VND}, we use multiple neighbourhood functions, passed as a vector of function pointers to the class constructor.\\
As such, it is easily possible to use any combination of neighbourhood functions; moreover, if a single function is given, the algorithm becomes equivalent to \textit{iterative search}. 
However, it was preferred to keep separate the 2 implementations, for the sake of clarity.




% ====================================================
% =============================================== TESTS
% ====================================================

\section{Inferential statistical analysis}

\subsection{Introduction}
The implemented algorithms offer a wide choice of parameters to be set, in terms of how the initial state is computed, how new candidate solutions are generated, and so on.\\
As such, it is important to evaluate which combinations offer the best performances, both in terms of \textbf{results} (the \textit{weighted completion time} defined above) and \textbf{execution time}.

The algorithms were tested on $60$ different problem instances: $30$ instances with $50$ jobs and $30$ instances with $100$ jobs.
All the instances had $20$ machines. 

2 types of tests were performed:
\begin{itemize}
    \item Test the \textit{iterative improvement} algorithm, by trying all different combinations of initial state generation (\textit{random} and \textit{RZ}), neighbourhood generation (\textit{transpose}, \textit{exchange}, \textit{insert}) and first/best improvement, for a total of $12$ different combinations of parameters.
    
    \item Test the \textit{variable neighbourhood descent} algorithm, by trying different combinations of neighbourhood generator functions. The algorithm was tested with \textit{Transpose, Exchange, Insert} and with \textit{Transpose, Insert, Exchange}. In both cases, the algorithm was set to use \textit{first improvement} and the \textit{RZ} heuristic for the starting state.
\end{itemize}

To have comparable results across the tests on a single problem instance, the \textbf{seed} used by the \textit{random number generator} was kept fixed across a single instance.

The tests were performed on the following machine:
\begin{itemize}
    \item Computer: Microsoft Surface Pro 4
    \item CPU: Intel Core i5-6300U at 2.4 GHz (clocked at 2.95 Ghz)
    \item RAM: 4 GB at 1867Mhz
\end{itemize}
 
 
\subsection{Exploratory analysis}
Before starting any statistical test, it is a good idea to visualize the data, so to see if it's immediately possible to notice any interesting structure in the results.

First of all, it is required to separate the data relative to the instances with $50$ jobs from the ones with $100$ jobs, as the values from the 2 sets are not comparable with each other.

Then, it is possible to plot \textbf{boxplots} that display summary statistics of the \textbf{execution times} and of the \textbf{result values}. Relatively to the optimization results, it is also visualized the boxplot of the \textbf{ideal optimization results}, the values that would be achieved by an exact solver.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.3\textwidth, center, keepaspectratio=1]{{"II_execution_time"}.pdf}
    \caption{\emph{Summary statistics of the execution time for \textbf{iterative improvement}, with different parameters.}}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.3\textwidth, center, keepaspectratio=1]{{"ii_exec_zoom"}.pdf}
    \caption{\emph{Summary statistics of the execution time for \textbf{iterative improvement}, with different parameters. The first 2 combinations were removed to see more in details the other ones.}}
\end{figure}

By looking at the execution times of \textbf{iterative improvement}, it is immediately possible to notice how \textit{first improvement} with \textit{random initial state} and \textit{exchange} or \textit{insert} neighbourhood functions is much slower than the other implementations.
Moreover, it is clear how the \textit{transpose} function is much faster than the other, as the number of generated neighbours is linear with respect to the number of jobs, instead of quadratic.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.3\textwidth, center, keepaspectratio=1]{{"II_results"}.pdf}
    \caption{\emph{Summary statistics of the optimization results for \textbf{iterative improvement}, with different parameters.}}
\end{figure}

The optimization results given by the algorithms seems to be all very close to each other regardless of the chosen parameters, with the obvious exception of the \textit{transpose} function: despite being faster, it generates a lower amount of new candidate solutions, and it's not surprising to see it perform worse than the other options.\\
The fact that the results are all quite close to each other means that the choice of initial parameters will be based mostly on execution time, which greatly simplify the problem of picking the "best" algorithm.\\ 
Moreover, we can see how the results are seemingly very close to the best theoretical results. We will soon evaluate whether there is a statistical difference between the ideal results and the ones provided by our heuristic algorithms.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth, center, keepaspectratio=1]{{"vnd_boxplot"}.pdf}
    \caption{\emph{Summary statistics of execution time and optimization results for \textbf{variable neighbourhood descent}, with different parameters.}}
\end{figure}

Relatively to \textit{variable neighbourhood descent}, we can see how \textbf{TIE} (\textit{Transpose, Insert, Exchange}) is generally faster than \textbf{TEI} (\textit{Transpose, Exchange, Insert}). Both options are however very fast, if compared to the times given by some of the variants of  \textit{iterative improvement} algorithms seen above.\\
As for the results, both options seem to give results that are pretty much equivalent, and once again very close to the theoretical optimum.

From this initial analysis, it seems that the best algorithms could be \textbf{iterative search} with \textit{RZ} heuristic and \textit{Exchange} function (using \textit{best} or \textit{first} improvement doesn't seem to change much, with the previous parameters) and \textbf{VND} with \textit{Transpose, Insert, Exchange}. \\
To get a definitive answer, however, more in-depth tests will be required.

\subsection{Summary statistics}

From the collected results, it is possible to compute a number of interesting statistics that will give some additional insight about the performances of the algorithms.\\
For both algorithms and for each combination of initial settings, it is possible to compute the \textit{mean}, the \textit{median}, the \textit{standard deviation} (and other statistics) relatively to the execution time and to the optimization results.\\
It is also possible to evaluate how distant the algorithms are from the best possible result.\\
This can be done by using the \textbf{MAPE} (\textit{mean absolute percentage error}), computed as

$$ MAPE = \frac{100}{n}\sum_{i=1}^n{\left|\frac{B_i - R_i}{B_i}\right|}$$

where $n$ is the number of instances ($30$ for each number of jobs), $B_i$ is the best possible solution for a given instance, and $R_i$ is the optimization result given by our algorithm.


    \begin{table}[H]
    \centering % centering table    
    \begin{tabular}{l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Initial Parameters} & \textcolor{BrickRed}{Minimum} & \textcolor{BrickRed}{Median} & \textcolor{BrickRed}{Mean} & \textcolor{BrickRed}{Maximum} & \textcolor{BrickRed}{Standard deviation}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{FI, Random, E}     & 76539 & 113272 & 112518 & 185083 & 22342\\ 
        \textcolor{MidnightBlue}{FI, Random, I}     & 186265 & 262628 & 264573 & 347115 & 39546\\
        \textcolor{MidnightBlue}{FI, Random, T}     & 224 & 438 & 479 & 911 & 169\\
        \textcolor{MidnightBlue}{FI, RZ, E}         & 2461 & 8192 & 8037 & 14341 & 3642\\
        \textcolor{MidnightBlue}{FI, RZ, I}         & 6834  & 19631 & 19934 & 34009 & 5576\\
        \textcolor{MidnightBlue}{FI, RZ, T}         & 11 & 32 & 34 & 96 & 18\\
        \textcolor{MidnightBlue}{BI, Random, E}     & 19544 & 25040 & 25956 & 35471 & 4474\\
        \textcolor{MidnightBlue}{BI, Random, I}     & 40502 & 59755 & 58112 & 72690 & 8897\\
        \textcolor{MidnightBlue}{BI, Random, T}     & 267 & 497 & 512 & 898 & 158\\
        \textcolor{MidnightBlue}{BI, RZ, E}         & 1706 & 5626 & 5635 & 10429 & 1869\\
        \textcolor{MidnightBlue}{BI, RZ, I}         & 9219 & 15135 & 15790 & 25937 & 4692\\
        \textcolor{MidnightBlue}{BI, RZ, T}         & 11 & 42 & 42 & 106 & 17\\
        \textcolor{MidnightBlue}{VND, TIE}         & 6122    &   10150 &  10120   &   18170  & 3143\\
        \textcolor{MidnightBlue}{VND, TEI}         & 8292    &   12060 &  12860   &   23600  & 4006
        \\[1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:100-exec}Summary statistics of the \textbf{execution times} (in milliseconds) of the \textbf{iterative improvement} and \textbf{VND} algorithms, with different initial parameters.}
    \end{table} 

    \begin{table}[H]
    \centering % centering table    
    \begin{tabular}{l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Initial Parameters} & \textcolor{BrickRed}{Minimum} & \textcolor{BrickRed}{Median} & \textcolor{BrickRed}{Mean} & \textcolor{BrickRed}{Maximum} & \textcolor{BrickRed}{Standard deviation}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{Ideal result}      & 1449000 & 1754000 &  1745000 & 1992000 & 109155 \\   
        \textcolor{MidnightBlue}{FI, Random, E} 	& 1474000 & 1783000 & 1773000 & 2029000 & 110586 \\  
        \textcolor{MidnightBlue}{FI, Random, I}     & 1484000 & 1791000 & 1782000 & 2027000 & 114707 \\
        \textcolor{MidnightBlue}{FI, Random, T}     & 2071000 & 2462000 & 2430000 & 2687000 & 145989 \\
        \textcolor{MidnightBlue}{FI, RZ, E}         & 1501000 & 1799000 & 1799000 & 2059000 & 111644 \\
        \textcolor{MidnightBlue}{FI, RZ, I}         & 1482000 & 1776000 & 1782000 & 2032000 & 111849 \\
        \textcolor{MidnightBlue}{FI, RZ, T}         & 1513000 & 1827000 & 1824000 & 2087000 & 114101 \\
        \textcolor{MidnightBlue}{BI, Random, E}     & 1508000 & 1837000 & 1829000 & 2086000 & 119963 \\
        \textcolor{MidnightBlue}{BI, Random, I}     & 1506000 & 1810000 & 1808000 & 2099000 & 120916 \\
        \textcolor{MidnightBlue}{BI, Random, T}     & 2075000 & 2490000 & 2449000 & 2675000 & 148046 \\
        \textcolor{MidnightBlue}{BI, RZ, E}         & 1504000 & 1805000 & 1805000 & 2078000 & 113938 \\
        \textcolor{MidnightBlue}{BI, RZ, I}         & 1502000 & 1793000 & 1788000 & 2063000 & 116300 \\
        \textcolor{MidnightBlue}{BI, RZ, T}         & 1513000 & 1828000 & 1825000 & 2088000 & 114601 \\
        \textcolor{MidnightBlue}{VND, TIE}         & 1488000    &   1791000 &  1784000   &   2062000  & 113651\\
        \textcolor{MidnightBlue}{VND, TEI}         & 1487000    &   1789000 &  1782000   &   2031000  & 110927\\
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:100-res}Summary statistics of the \textbf{optimization results} of the \textbf{iterative improvement} and \textbf{VND} algorithms, with different initial parameters, and instances with \textbf{100 jobs}.}
    \end{table} 


    \begin{table}[H]
        \centering % centering table    
        \begin{tabular}{l l l l l l} % creating eight columns
            \hline
            \hline 
            \\[-1.5ex]
            \textcolor{BrickRed}{Initial Parameters} & \textcolor{BrickRed}{Minimum} & \textcolor{BrickRed}{Median} & \textcolor{BrickRed}{Mean} & \textcolor{BrickRed}{Maximum} & \textcolor{BrickRed}{Standard deviation}\\ [0.5ex]
            \hline % inserts single-line
            \\[-1.5ex]
           \textcolor{MidnightBlue}{FI, Random, E} 	 &   2900  &   4571  &  4692 &   5177 &  779 \\
           \textcolor{MidnightBlue}{FI, Random, I}    &   6794  &  12020  & 11950 &  13260 &  2265 \\
           \textcolor{MidnightBlue}{FI, Random, T}    &  21.00  &  45.50  & 45.17 &  53.25 &  13 \\
           \textcolor{MidnightBlue}{FI, RZ, E}        &   40.0  &  265.0  & 310.5 &  400.5 &  200 \\
           \textcolor{MidnightBlue}{FI, RZ, I}        &  349.0  & 1095.0  &1177.0 & 1433.0 &  505 \\
           \textcolor{MidnightBlue}{FI, RZ, T}        &  1.000  &  3.000  & 3.967 &  5.000 &  3 \\
           \textcolor{MidnightBlue}{BI, Random, E}    &   1191  &   1534  &  1554 &   1698 &  235 \\
           \textcolor{MidnightBlue}{BI, Random, I}    &   2772  &   3563  &  3630 &   3902 &  490 \\
           \textcolor{MidnightBlue}{BI, Random, T}    &  30.00  &  49.50  & 56.13 &  70.00 &  18 \\
           \textcolor{MidnightBlue}{BI, RZ, E}        &   37.0  &  329.0  & 333.8 &  425.2 &  182 \\
           \textcolor{MidnightBlue}{BI, RZ, I}        &  462.0  &  985.5  &1051.0 & 1285.0 &  363 \\
           \textcolor{MidnightBlue}{BI, RZ, T}        &  1.000  &  4.500  & 5.167 &  6.750 &  3 \\
           \textcolor{MidnightBlue}{VND, TIE}         & 236.0    &   549.0 &  611.2    &   1393.0   & 269\\
           \textcolor{MidnightBlue}{VND, TEI}         & 382.0    &   914.0 &  899.2   &   2178.0   & 408
            \\[1ex] % [1ex] adds vertical space
            \hline % inserts single-line
        \end{tabular}
        \caption{\label{tab:50-exec}Summary statistics of the \textbf{execution times} (in milliseconds) of the \textbf{iterative improvement} and \textbf{VND} algorithms, with different initial parameters, and instances with \textbf{50 jobs}.}
    \end{table} 



    \begin{table}[H]
        \centering % centering table    
        \begin{tabular}{l l l l l l} % creating eight columns
            \hline
            \hline 
            \\[-1.5ex]
            \textcolor{BrickRed}{Initial Parameters} & \textcolor{BrickRed}{Minimum} & \textcolor{BrickRed}{Median} & \textcolor{BrickRed}{Mean} & \textcolor{BrickRed}{Maximum} & \textcolor{BrickRed}{Standard deviation}\\ [0.5ex]
            \hline % inserts single-line
            \\[-1.5ex]
            \textcolor{MidnightBlue}{Ideal result}  & 465500  &  590300 & 586200  &  666600 & 44161\\
            \textcolor{MidnightBlue}{FI, Random, E}  & 472200 & 601300 & 597800  &  679600 & 46274\\
            \textcolor{MidnightBlue}{FI, Random, I}  & 467700 & 599900 & 595500  &  673100 & 47417\\
            \textcolor{MidnightBlue}{FI, Random, T}  & 639500 & 770900 & 779200  & 1006000 & 64347\\
            \textcolor{MidnightBlue}{FI, RZ, E}      & 474600 & 608800 & 602900  &  686200 & 46776\\
            \textcolor{MidnightBlue}{FI, RZ, I}      & 478200 & 603900 & 596100  &  675500 & 45197\\
            \textcolor{MidnightBlue}{FI, RZ, T}      & 480100 & 612900 & 607700  &  696500 & 47827\\
            \textcolor{MidnightBlue}{BI, Random, E}  & 482200 & 616800 & 610800  &  706900 & 47422\\
            \textcolor{MidnightBlue}{BI, Random, I}  & 474700 & 599600 & 602600  &  689700 & 47814\\
            \textcolor{MidnightBlue}{BI, Random, T}  & 640600 & 773700 & 784200  & 1017000 & 65121\\
            \textcolor{MidnightBlue}{BI, RZ, E}      & 474600 & 608600 & 602500  &  680200 & 46325\\
            \textcolor{MidnightBlue}{BI, RZ, I}      & 473000 & 604800 & 597900  &  679000 & 46515\\
            \textcolor{MidnightBlue}{BI, RZ, T}      & 480100 & 612900 & 607900  &  696500 & 48075\\
            \textcolor{MidnightBlue}{VND, TIE}         & 478200   &   598400 &  597300    &   674900   & 45947\\
            \textcolor{MidnightBlue}{VND, TEI}         & 477600    &   599700 &  596700   &   676500   & 45846
            
            \\[1ex] % [1ex] adds vertical space
            \hline % inserts single-line
        \end{tabular}
        \caption{\label{tab:50-res}Summary statistics of the \textbf{optimization results} of the \textbf{iterative improvement} and \textbf{VND} algorithms, with different initial parameters, and instances with \textbf{50 jobs}.}
    \end{table} 

    \begin{table}[H]
        \centering % centering table    
        \begin{tabular}{l l l l} % creating eight columns
            \hline
            \hline 
            \\[-1.5ex]
            \textcolor{BrickRed}{Initial Parameters} & \textcolor{BrickRed}{100 Jobs} & \textcolor{BrickRed}{50 Jobs} & \textcolor{BrickRed}{Mean}\\ [0.5ex]
            \hline % inserts single-line
            \\[-1.5ex]
            \textcolor{MidnightBlue}{FI, Random, E} & 1.607625   & 1.9744         & 1.791012    \\
            \textcolor{MidnightBlue}{FI, Random, I} & 2.019402   &  1.578662      & 1.799032    \\
            \textcolor{MidnightBlue}{FI, Random, T} & 39.3606    &  33.03201      & 36.1963     \\
            \textcolor{MidnightBlue}{FI, RZ, E}     & 3.099908   &  2.840713      & 2.97031  \\
            \textcolor{MidnightBlue}{FI, RZ, I}     & 2.137591   &   1.702044     & 1.919817    \\
            \textcolor{MidnightBlue}{FI, RZ, T}     & 4.53555    &    3.664744    & 4.100149    \\
            \textcolor{MidnightBlue}{BI, Random, E} & 4.760639   &   4.20176      & 4.4812    \\
            \textcolor{MidnightBlue}{BI, Random, I} & 3.573396   &    2.780781    & 3.177088   \\
            \textcolor{MidnightBlue}{BI, Random, T} & 40.41302   &   33.88196     & 37.14749    \\
            \textcolor{MidnightBlue}{BI, RZ, E}     & 3.450056   &   2.787234     & 3.118645   \\
            \textcolor{MidnightBlue}{BI, RZ, I}     & 2.462845   &  1.994742      & 2.228794   \\
            \textcolor{MidnightBlue}{BI, RZ, T}     & 4.547392   &   3.686519     & 4.116955   \\ 
            \textcolor{MidnightBlue}{VND, TIE}     & 2.210744   &   1.9007523    & 2.055748  \\ 
            \textcolor{MidnightBlue}{VND, TEI}     & 2.11388   &   1.8048572     & 1.959371  
            \\[1ex] % [1ex] adds vertical space
            \hline % inserts single-line
        \end{tabular}
        \caption{\label{tab:mape}\textbf{Mean average percentage error} for the various algorithms, computed with respect to the best possible solution.}
    \end{table} 
    
\newpage

From the previous tables, it seems that the best results are given by \textbf{first improvement} with \textbf{random} start and \textbf{exchange} or \textbf{insert}.\\
These combinations are however the slowest ones, while \textbf{VND} with \textbf{transpose, exchange, insert} seems to give similar results at much higher speed.
Moreover, a difference of $0.1\%$ might not even be significant from a statistical point of view. We will analyse this more in details in the next section.  

\subsection{Inferential statistical tests - Introduction}
From the previous plots and tables it seems quite clear that some algorithms perform better than others.\\
However, some of these differences might not be \textit{significant} from a statistical point of view, and be instead caused by randomness in the test instances or in the algorithms.

In this section, the previous algorithms are compared to each other, to understand which ones are better in terms of speed and result quality.

Before performing any test, a few considerations about the testing methodology should be made.\\
First, the instances with 50 and 100 jobs should  be treated separately, as they clearly compose different populations.\\
Moreover, the tests to be performed are heavily dependent on the distributions of the populations that are considered.\\
Most tests assume that the samples from a given population are \textit{independent and identically distributed} (\textbf{I.I.D.}): the first condition can be considered true as all the instances are considered separately, without any of them having influences on the others; the second condition is harder to verify, but can be considered true as long as instances with 50 and 100 jobs are considered separately.

\textbf{Paired t-test} also assumes the populations to be \textit{normally distributed}, and to have the same \textit{variance}. The latter constraint can be removed by using \textbf{Welch's t-test}, which is provided by default by \textbf{R} \cite{welch1947generalization}. \\
The \textit{normality} of the distribution can be checked in several ways, among which the \textbf{Shapiro-Wilk} test is one of the most common. \cite{shapiro1965analysis}
The test assumes normality of the distribution as \textit{null hypothesis}.

If the normality condition isn't verified, it is necessary to resort to \textit{non-parametric} tests, such as the \textbf{Wilcoxon signed-rank test} \cite{wilcoxon1945individual} for comparing the mean of two populations, or the \textbf{Kruskal-Wallis} test to compare more than two populations \cite{kruskal1952use}. The latter test assumes as null hypothesis that all the populations have the same mean, similarly to \textbf{ANOVA}.

One last remark is that using \textit{t-test} to compare more than two populations is generally ill-advised (\href{http://www.stat.berkeley.edu/~mgoldman/Section0402.pdf}{http://www.stat.berkeley.edu/~mgoldman/Section0402.pdf}). One way to overcome the issue is to employ the so-called \textbf{Bonferroni correction}, which can however give rather conservative estimates. \\   
A better approach is to initially compare the populations with \textbf{ANOVA} or \textbf{Kruskal-Wallis}, and then proceed with pairwise tests if necessary.

\subsection{Tests on VND}

We can compare the results of \textbf{VND}, and see which combination of initial parameters is superior.

$\bullet$ First, we should check the normality of the distributions.

\begin{table}[H]
    \centering % centering table    
    \begin{tabular}{l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm} & \textcolor{BrickRed}{p-value, Execution time} & \textcolor{BrickRed}{p-value, Result} \\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{VND, TIE, 100 Jobs}  & 0.03005 & 0.5337    \\
        \textcolor{MidnightBlue}{VND, TIE, 50 Jobs}   & 0.00832  & 0.5934   \\
        \textcolor{MidnightBlue}{VND, TEI, 100 Jobs}  & 0.005474  & 0.4946    \\
        \textcolor{MidnightBlue}{VND, TEI, 50 Jobs}   & 0.005752  &  0.6878  \\
        \textcolor{MidnightBlue}{Ideal result, 100 Jobs}   & & 0.4312\\       
        \textcolor{MidnightBlue}{Ideal result, 50 Jobs}        & & 0.6698    
        \\[1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:shapiro}\textbf{p-values} of the \textbf{Shapiro-Wilk} test for the various algorithms.}
\end{table} 

We can safely infer that the optimization results follow a normal distribution, while the execution times do not.\\
As such, they will be compared using the \textbf{Wilcoxon signed-rank test}.

\begin{table}[H]
    \centering % centering table    
    \begin{tabular}{l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm} & \textcolor{BrickRed}{p-value, Execution time} & \textcolor{BrickRed}{Mean TIE} & \textcolor{BrickRed}{Mean TEI}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{VND, 100 Jobs}  & 0.00665 & 10120 & 12860\\
        \textcolor{MidnightBlue}{VND, 50 Jobs}   & 0.002688  & 611.2 &  899.2  
        \\[1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:vnd-exec}\textbf{p-values} of the \textbf{Wilcoxon signed-rank test} test for the \textbf{execution time} of the various algorithms.}
\end{table} 

From the result we can infer that using \textbf{Transpose, Insert, Exchange} is the faster option.

$\bullet$ Then, we can compare the optimization results, keeping into account the optimal results too. As we have 3 populations (for each instance size), which we have verified to be gaussian, we can use the \textbf{ANOVA} test.

\begin{table}[H]
    \centering % centering table    
    \begin{tabular}{l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm} & \textcolor{BrickRed}{p-value, Optimization result} & \textcolor{BrickRed}{Mean TIE} & \textcolor{BrickRed}{Mean TEI} & \textcolor{BrickRed}{Mean Ideal}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{VND, 100 Jobs}  & 0.3259 & 1784000 & 1782000 & 1745000\\
        \textcolor{MidnightBlue}{VND, 50 Jobs}   & 0.5677  & 597300 &  596700 & 586200  
        \\[1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:vnd-res}\textbf{p-values} of the \textbf{ANOVA test} test for the \textbf{optimization results} of the various algorithms.}
\end{table} 

It seems that there is no statistical difference not only between the 2 algorithms, but also with respect to the optimal solution.\\
As such, the choice of initial parameters will be based on the \textbf{execution speed}; as we have seen, the fastest option is \textbf{Transpose, Insert, Exchange}.

\subsection{Tests on Iterative Improvement}

Tests on Iterative improvement are more complex, due to the high number of input parameters that can be set.\\
The approach we can use is to keep fixed a certain number of parameters, and test the differences on the other. For instance, we can fix the how the \textbf{starting state} and the \textbf{neighbours} are computed, and see if \textbf{first improvement} is better than \textbf{best improvement}.\\
Depending on the parameter that is evaluated, we could have 2 or more options available, and suitable tests have to be used.\\
In every case, it's also required to check the normality of the distributions. The results of the \textbf{Shapiro-Wilk} test are not reported for brevity, but the approach is similar to the one used in the previous section. Depending on the results of this test, the appropriate follow-up tests have been used.

As a preliminary test, we can use \textbf{ANOVA} on the execution times and on the optimization results. In this case, all the 12 combinations of initial parameters are compared at once.

\begin{table}[H]
    \centering % centering table    
    \begin{tabular}{l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm} & \textcolor{BrickRed}{p-value, Execution time} & \textcolor{BrickRed}{p-value, Optimization result}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{100 Jobs}  & 2.2e-16 & 2.2e-16\\
        \textcolor{MidnightBlue}{50 Jobs}   & 2.2e-16  & 2.2e-16   
        \\[1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-anova}\textbf{p-values} of the \textbf{ANOVA test} test for the \textbf{execution times} and \textbf{optimization results} of the various algorithms.}
\end{table} 

As expected, in every case there are significant differences in the population means. \textbf{ANOVA} however doesn't tell which are the statistically different populations, which means that more detailed tests have to be carried out.

\subsection{RZ Heuristic VS Random initial state}
In this section it is investigated which is the best approach to compute the initial state of the problem.\\
The \textbf{RZ heuristic} and the \textbf{random} initial state are compared, while the other parameters are kept fixed. \\
Depending on the distribution of the populations, the appropriate tests were performed. \textbf{Bonferroni correction} is used to deal with the repeated pairwise tests, and so the significance level is divided by the number of hypotheses: assuming the usual significance at $\alpha = 0.05$, we have to use $\alpha = 0.05 / 6 = 0.008$.

\begin{table}[H]
    \begin{tabular}{l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2} & \textcolor{BrickRed}{T-test} & \textcolor{BrickRed}{Wilc.} & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{FI, RZ, T} & \textcolor{MidnightBlue}{FI, Random, T} &  & 3e-11  & 34.83 & 479.40 \\ 
        \textcolor{MidnightBlue}{FI, RZ, E} & \textcolor{MidnightBlue}{FI, Random, E} &  & 1.7e-17 & 8037.00 & 112518.03 \\ 
        \textcolor{MidnightBlue}{FI, RZ, I} & \textcolor{MidnightBlue}{FI, Random, I} &  & 3.4e-17 & 19933.67 & 264573.10 \\ 
        \textcolor{MidnightBlue}{BI, RZ, T} & \textcolor{MidnightBlue}{BI, Random, T} &  & 3e-11 & 41.93 & 512.93 \\ 
        \textcolor{MidnightBlue}{BI, RZ, E} & \textcolor{MidnightBlue}{BI, Random, E} &  & 1.7e-17 & 5634.90 & 25956.37 \\ 
        \textcolor{MidnightBlue}{BI, RZ, I} & \textcolor{MidnightBlue}{BI, Random, I} &  & 3e-11 & 15790.23 & 58112.23 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-initialstate100exec}\textbf{p-values} of the tests for the \textbf{execution times} on \textbf{100 jobs} instances, changing the \textit{Initial state} computation.}
\end{table} 


\begin{table}[H]
    \begin{tabular}{l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2} & \textcolor{BrickRed}{T-test} & \textcolor{BrickRed}{Wilc.}  & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{FI, RZ, T} & \textcolor{MidnightBlue}{FI, Random, T} & 1.4e-24 &  & 1824292.40 & 2430299.40 \\ 
        \textcolor{MidnightBlue}{FI, RZ, E} & \textcolor{MidnightBlue}{FI, Random, E} & 0.37 &  & 1799165.57 & 1773176.93 \\ 
        \textcolor{MidnightBlue}{FI, RZ, I} & \textcolor{MidnightBlue}{FI, Random, I} & 0.98 &  & 1782487.10 & 1781657.14 \\ 
        \textcolor{MidnightBlue}{BI, RZ, T} & \textcolor{MidnightBlue}{BI, Random, T} & 6.5e-25 &  & 1824527.83 & 2448811.80 \\ 
        \textcolor{MidnightBlue}{BI, RZ, E} & \textcolor{MidnightBlue}{BI, Random, E} & 0.45 &  & 1805388.90 & 1828531.93 \\ 
        \textcolor{MidnightBlue}{BI, RZ, I} & \textcolor{MidnightBlue}{BI, Random, I} & 0.53 &  & 1788360.23 & 1807937.30 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-initialstate100res}\textbf{p-values} of the tests for the \textbf{results} on \textbf{100 jobs} instances, changing the \textit{Initial state} computation.}
\end{table} 

By looking at the adjusted p-values, it seems that the \textbf{RZ} performs better only when \textbf{transpose} is used as neighbour generator. This is not suprising, as the number of candidate solutions that is explored is much smaller than in the other cases. As such, having a good initial candidate solution can have a much bigger impact.
In the other cases, we can consider the execution times. In all cases, using the \textbf{RZ} heuristic gives shorter computation time. As there is no statistical evidence that \textbf{random} gives better results, we can conclude that using the \textbf{RZ} heuristic is the best choice.

\begin{table}[H]
    \begin{tabular}{l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2} & \textcolor{BrickRed}{T-test} & \textcolor{BrickRed}{Wilc.}  & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
         \textcolor{MidnightBlue}{FI, RZ, T}&  \textcolor{MidnightBlue}{FI, Random, T} &  & 2.8e-11 & 3.97 & 45.17 \\ 
         \textcolor{MidnightBlue}{FI, RZ, E}&  \textcolor{MidnightBlue}{FI, Random, E} &  & 3e-11 & 310.53 & 4691.67 \\ 
         \textcolor{MidnightBlue}{FI, RZ, I}&  \textcolor{MidnightBlue}{FI, Random, I} &  & 3e-11 & 1176.97 & 11954.67 \\ 
         \textcolor{MidnightBlue}{BI, RZ, T}&  \textcolor{MidnightBlue}{BI, Random, T} &  & 2.8e-11 &  5.17 & 56.13 \\ 
         \textcolor{MidnightBlue}{BI, RZ, E}&  \textcolor{MidnightBlue}{BI, Random, E} &  & 3e-11 & 333.83 & 1553.77 \\ 
         \textcolor{MidnightBlue}{BI, RZ, I}&  \textcolor{MidnightBlue}{BI, Random, I} &  & 1.7e-17 & 1051.07 & 3629.73 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-initialstate50exec}\textbf{p-values} of the tests for the \textbf{execution times} on \textbf{50 jobs} instances, changing the\textit{Initial state} computation.}
\end{table} 

\begin{table}[H]
    \begin{tabular}{l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2} & \textcolor{BrickRed}{T-test} & \textcolor{BrickRed}{Wilc.} & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{FI, RZ, T} & \textcolor{MidnightBlue}{FI, Random, T} &  & 1.1e-15 & 607710.27 & 779167.53 \\ 
        \textcolor{MidnightBlue}{FI, RZ, E} & \textcolor{MidnightBlue}{FI, Random, E} &  & 0.63 &  602852.33 & 597764.77 \\ 
        \textcolor{MidnightBlue}{FI, RZ, I} & \textcolor{MidnightBlue}{FI, Random, I} &  & 0.97 & 596090.40 & 595541.27 \\ 
        \textcolor{MidnightBlue}{BI, RZ, T} & \textcolor{MidnightBlue}{BI, Random, T} &  & 1.1e-15 &   607855.87 & 784191.83 \\ 
        \textcolor{MidnightBlue}{BI, RZ, E} & \textcolor{MidnightBlue}{BI, Random, E} &  & 0.41 & 602511.47 & 610805.03 \\ 
        \textcolor{MidnightBlue}{BI, RZ, I} & \textcolor{MidnightBlue}{BI, Random, I} &  & 0.62 & 597905.50 & 602568.37 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-initialstate50res}\textbf{p-values} of the tests for the \textbf{results} on \textbf{50 jobs} instances, changing the\textit{Initial state} computation.}
\end{table} 

Looking at the instances with \textbf{50 jobs} further confirms what was observed above.






\subsection{First improvement VS Best improvement}
In this section it is tested which \textbf{iterative improvement} version is the better option. The approach to testing is the same of the previous section.

\begin{table}[H]
    \begin{tabular}{l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2} & \textcolor{BrickRed}{T-test} & \textcolor{BrickRed}{Wilc.} & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{FI, RZ, T}     & \textcolor{MidnightBlue}{BI, RZ, T}     &  & 0.035 &  34.83 & 41.93 \\ 
        \textcolor{MidnightBlue}{FI, RZ, E}     & \textcolor{MidnightBlue}{BI, RZ, E}     & 0.0025 &  & 8037.00 & 5634.90 \\ 
        \textcolor{MidnightBlue}{FI, RZ, I}     & \textcolor{MidnightBlue}{BI, RZ, I}     & 0.0029 &  & 19933.67 & 15790.23 \\ 
        \textcolor{MidnightBlue}{FI, Random, T} & \textcolor{MidnightBlue}{BI, Random, T} &  & 0.32 &  479.40 & 512.93 \\ 
        \textcolor{MidnightBlue}{FI, Random, E} & \textcolor{MidnightBlue}{BI, Random, E} &  & 1.7e-17 &  112518.03 & 25956.37 \\ 
        \textcolor{MidnightBlue}{BI, Random, I} & \textcolor{MidnightBlue}{BI, Random, I} & 3.5e-23 &  & 264573.10 & 58112.23 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-ty100ex}\textbf{p-values} of the tests for the \textbf{execution times} on \textbf{100 jobs} instances, changing the \textit{First improvement/Best improvement} setting.}
\end{table} 


\begin{table}[H]
    \begin{tabular}{l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2} & \textcolor{BrickRed}{T-test} & \textcolor{BrickRed}{Wilc.} & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{FI, RZ, T}     & \textcolor{MidnightBlue}{BI, RZ, T}     & 0.99 &  & 1824292.40 & 1824527.83 \\ 
        \textcolor{MidnightBlue}{FI, RZ, E}     & \textcolor{MidnightBlue}{BI, RZ, E}     & 0.83 &  & 1799165.57 & 1805388.90 \\ 
        \textcolor{MidnightBlue}{FI, RZ, I}     & \textcolor{MidnightBlue}{BI, RZ, I}     & 0.84 &  & 1782487.10 & 1788360.23 \\ 
        \textcolor{MidnightBlue}{FI, Random, T} & \textcolor{MidnightBlue}{BI, Random, T} & 0.63 &  &2430299.40 & 2448811.80 \\ 
        \textcolor{MidnightBlue}{FI, Random, E} & \textcolor{MidnightBlue}{BI, Random, E} & 0.068 &  & 1773176.93 & 1828531.93 \\ 
        \textcolor{MidnightBlue}{FI, Random, I} & \textcolor{MidnightBlue}{BI, Random, I} & 0.4 &  & 1781657.14 & 1807937.30 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-ty100res}\textbf{p-values} of the tests for the \textbf{results} on \textbf{100 jobs} instances, changing the \textit{First improvement/Best improvement} setting.}
\end{table} 

There is no significant difference in terms of \textbf{optimization results}. However, \textbf{Best improvement} is faster in every significant case, making it the best option.



\begin{table}[H]
    \begin{tabular}{l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2} & \textcolor{BrickRed}{T-test} & \textcolor{BrickRed}{Wilc.} & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{FI, RZ, T}     & \textcolor{MidnightBlue}{BI, RZ, T}     &  & 0.11 &   3.97 & 5.17 \\ 
        \textcolor{MidnightBlue}{FI, RZ, E}     & \textcolor{MidnightBlue}{BI, RZ, E}     &  & 0.47 &   310.53 & 333.83 \\ 
        \textcolor{MidnightBlue}{FI, RZ, I}     & \textcolor{MidnightBlue}{BI, RZ, I}     & 0.27 &  &  1176.97 & 1051.07 \\ 
        \textcolor{MidnightBlue}{FI, Random, T} & \textcolor{MidnightBlue}{BI, Random, T} &  & 0.029 &  45.17 & 56.13 \\ 
        \textcolor{MidnightBlue}{FI, Random, E} & \textcolor{MidnightBlue}{BI, Random, E} & 3.3e-21 &  &  4691.67 & 1553.77 \\ 
        \textcolor{MidnightBlue}{FI, Random, I} & \textcolor{MidnightBlue}{BI, Random, I} & 2.5e-19 &  &  11954.67 & 3629.73 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-ty50ex}\textbf{p-values} of the tests for the \textbf{execution times} on \textbf{50 jobs} instances, changing the \textit{First improvement/Best improvement} setting.}
\end{table} 





\begin{table}[H]
    \begin{tabular}{l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2} & \textcolor{BrickRed}{T-test} & \textcolor{BrickRed}{Wilc.} & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
                
        \textcolor{MidnightBlue}{FI, RZ, T}     & \textcolor{MidnightBlue}{BI, RZ, T}     & 0.99 &  &  607710.27 & 607855.87 \\ 
        \textcolor{MidnightBlue}{FI, RZ, E}     & \textcolor{MidnightBlue}{BI, RZ, E}     & 0.98 &  &  602852.33 & 602511.47 \\ 
        \textcolor{MidnightBlue}{FI, RZ, I}     & \textcolor{MidnightBlue}{BI, RZ, I}     & 0.88 &  & 596090.40 & 597905.50 \\ 
        \textcolor{MidnightBlue}{FI, Random, T} & \textcolor{MidnightBlue}{BI, Random, T} &  & 0.64 &  779167.53 & 784191.83 \\ 
        \textcolor{MidnightBlue}{FI, Random, E} & \textcolor{MidnightBlue}{BI, Random, E} & 0.29 &  &  597764.77 & 610805.03 \\ 
        \textcolor{MidnightBlue}{FI, Random, I} & \textcolor{MidnightBlue}{BI, Random, I} & 0.57 &  &  595541.27 & 602568.37 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-ty50res}\textbf{p-values} of the tests for the \textbf{results} on \textbf{50 jobs} instances, changing the \textit{First improvement/Best improvement} setting.}
\end{table} 


The previous claim is confirmed by the \textbf{50 jobs} instances.



\subsection{Transpose VS Exchange VS Insert}
This last section will compare the different ways to generate neighbours. As there are 3 different possibilities, it is better to first perform a \textbf{Kruskal-Wallis} test on the 3 populations, and then proceed with pairwise tests if required.

\begin{table}[H]
    \hspace*{-1.8cm}
    \begin{tabular}{l l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2}  & \textcolor{BrickRed}{Algorithm 3} & \textcolor{BrickRed}{Kruskal-Wallis} & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2} & \textcolor{BrickRed}{Mean 3}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        
        \textcolor{MidnightBlue}{FI, RZ, T}     & \textcolor{MidnightBlue}{FI, RZ, E}     & \textcolor{MidnightBlue}{FI, RZ, I}& 2.2e-16 & 34.83 & 8037.00 & 19933.67 \\ 
        \textcolor{MidnightBlue}{BI, RZ, T}     & \textcolor{MidnightBlue}{BI, RZ, E}     & \textcolor{MidnightBlue}{BI, RZ, I} & 2.2e-16 & 41.93 & 5634.90 & 15790.23 \\ 
        \textcolor{MidnightBlue}{FI, Random, T} & \textcolor{MidnightBlue}{FI, Random, E} & \textcolor{MidnightBlue}{FI, Random, I} & 2.2e-16 & 479.40 & 112518.03 & 264573.10 \\ 
        \textcolor{MidnightBlue}{BI, Random, T} & \textcolor{MidnightBlue}{BI, Random, E} & \textcolor{MidnightBlue}{BI, Random, I} &2.2e-16 & 512.93 & 25956.37 & 58112.23 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-n100exec}\textbf{p-values} of the tests for the \textbf{execution times} on \textbf{100 jobs} instances, changing the \textit{neighbourhood generation} setting.}
\end{table} 


\begin{table}[H]
    \hspace*{-2.5cm}
    \begin{tabular}{l l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2}  & \textcolor{BrickRed}{Algorithm 3} & \textcolor{BrickRed}{Kruskal-Wallis} & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2} & \textcolor{BrickRed}{Mean 3}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        
        \textcolor{MidnightBlue}{FI, RZ, T}     & \textcolor{MidnightBlue}{FI, RZ, E}     & \textcolor{MidnightBlue}{FI, RZ, I} & 0.23 & 1824292.40 & 1799165.57 & 1782487.10 \\ 
        \textcolor{MidnightBlue}{BI, RZ, T}     & \textcolor{MidnightBlue}{BI, RZ, E}     & \textcolor{MidnightBlue}{BI, RZ, I} & 0.32 & 1824527.83 & 1805388.90 & 1788360.23 \\ 
        \textcolor{MidnightBlue}{FI, Random, T} & \textcolor{MidnightBlue}{FI, Random, E} & \textcolor{MidnightBlue}{FI, Random, I} & 1.495e-13 & 2430299.40 & 1773176.93 & 1781657.14 \\ 
        \textcolor{MidnightBlue}{BI, Random, T} & \textcolor{MidnightBlue}{BI, Random, E} & \textcolor{MidnightBlue}{BI, Random, I} & 1.215e-13 & 2448811.80 & 1828531.93 & 1807937.30 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-n100res}\textbf{p-values} of the tests for the \textbf{results} on \textbf{100 jobs} instances, changing the \textit{neighbourhood generation} setting.}
\end{table} 


\begin{table}[H]
    \hspace*{-1.8cm}
    \begin{tabular}{l l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2}  & \textcolor{BrickRed}{Algorithm 3} & \textcolor{BrickRed}{Kruskal-Wallis} & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2} & \textcolor{BrickRed}{Mean 3}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        
           \textcolor{MidnightBlue}{FI, RZ, T}     & \textcolor{MidnightBlue}{FI, RZ, E}     & \textcolor{MidnightBlue}{FI, RZ, I} & 2.2e-16 & 3.97 & 310.53 & 1176.97 \\ 
           \textcolor{MidnightBlue}{BI, RZ, T}     & \textcolor{MidnightBlue}{BI, RZ, E}     & \textcolor{MidnightBlue}{BI, RZ, I} & 2.2e-16 & 5.17 & 333.83 & 1051.07 \\ 
           \textcolor{MidnightBlue}{FI, Random, T} & \textcolor{MidnightBlue}{FI, Random, E} & \textcolor{MidnightBlue}{FI, Random, I} & 2.2e-16 & 45.17 & 4691.67 & 11954.67 \\ 
           \textcolor{MidnightBlue}{BI, Random, T} & \textcolor{MidnightBlue}{BI, Random, E} & \textcolor{MidnightBlue}{BI, Random, I} & 2.2e-16 & 56.13 & 1553.77 & 3629.73 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-n50exec}\textbf{p-values} of the tests for the \textbf{execution times} on \textbf{50 jobs} instances, changing the \textit{neighbourhood generation} setting.}
\end{table} 


\begin{table}[H]
    \hspace*{-2.2cm}
    \begin{tabular}{l l l l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm 1} & \textcolor{BrickRed}{Algorithm 2}  & \textcolor{BrickRed}{Algorithm 3} & \textcolor{BrickRed}{Kruskal-Wallis} & \textcolor{BrickRed}{Mean 1} & \textcolor{BrickRed}{Mean 2} & \textcolor{BrickRed}{Mean 3}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
          \textcolor{MidnightBlue}{FI, RZ, T}     & \textcolor{MidnightBlue}{FI, RZ, E} & \textcolor{MidnightBlue}{FI, RZ, I} & 0.47 & 607710.27 & 602852.33 & 596090.40 \\ 
          \textcolor{MidnightBlue}{BI, RZ, T}     & \textcolor{MidnightBlue}{BI, RZ, E} & \textcolor{MidnightBlue}{BI, RZ, I} & 0.58 & 607855.87 & 602511.47 & 597905.50 \\ 
          \textcolor{MidnightBlue}{FI, Random, T} & \textcolor{MidnightBlue}{FI, Random, E} & \textcolor{MidnightBlue}{FI, Random, I} & 2.64e-13 & 779167.53 & 597764.77 & 595541.27 \\ 
          \textcolor{MidnightBlue}{BI, Random, T} & \textcolor{MidnightBlue}{BI, Random, E} & \textcolor{MidnightBlue}{BI, Random, I} & 3.078e-13 & 784191.83 & 610805.03 & 602568.37 \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-n50res}\textbf{p-values} of the tests for the \textbf{results} on \textbf{50 jobs} instances, changing the \textit{neighbourhood generation} setting.}
\end{table} 

The results of these tables are quite interesting: if the \textbf{RZ} heuristic is used, there is no statistical evidence that one way to generate \textbf{neighbours} is better than another. As such, taking the fastest option, i.e. \textbf{transpose}, seems to be the best idea.

Combining all the previous results together, we can conclude that \textbf{best improvement, RZ heuristic, transpose} is the overall best combination. It's one of the fastest combinations, and its results cannot be said to be worse than the ones of other, slower, combinations.


\section{Addendum: improvement on Iterative search}
From the previous results, it emerges how \textbf{first improvement} can be substantially slower than other combinations, if certain input parameters are set.\\
The main reason is that the entire set of neighbours of a state is generated, while in practice it would suffice to generate neighbours as long as an improving state (i.e. one with lower \textit{weighted completion time}) is found.

To reduce the computation time of \textbf{first improvement}, the neighbourhood generator functions have been modified, so that no unnecessary neighbours are created.

Below are reported some examples of how this modification can improve execution time.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth, center, keepaspectratio=1]{{"improved_ii"}.pdf}
    \caption{\emph{Differences in \textbf{execution time} between the \textit{old} and \textit{new} version of \textbf{First improvement}. \textbf{Random, Insert} are compared above, while \textbf{RZ, Exchange} are compared below.}}
\end{figure}


\begin{table}[H]
    \hspace*{-2.2cm}
    \begin{tabular}{l l l l} % creating eight columns
        \hline
        \hline 
        \\[-1.5ex]
        \textcolor{BrickRed}{Algorithm} & \textcolor{BrickRed}{t-test} & \textcolor{BrickRed}{Mean New} & \textcolor{BrickRed}{Mean Old}\\ [0.5ex]
        \hline % inserts single-line
        \\[-1.5ex]
        \textcolor{MidnightBlue}{FI, Random, I}  & 2e-22 & 63216.50 & 264573.10  \\ 
        \textcolor{MidnightBlue}{BI, RZ, E}     & 0.2992 & 7204.5 & 8037.0  \\ 
        [1ex] % [1ex] adds vertical space
        \hline % inserts single-line
    \end{tabular}
    \caption{\label{tab:ii-imp}\textbf{p-values} of the \textbf{t-tests} for the \textbf{execution times} on \textbf{100 jobs} instances. Old and new versions of \textbf{First improvement} are compared.}
\end{table} 

It can be seen how the improvements in execution time are strongly related to the initial parameters that are set. While there is a big improvement in the case of \textbf{Random, Insert} (a \textit{speed-up} of 320\%), in the case of \textbf{RZ, E} there's no statistical evidence of any improvement.

\newpage
\bibliographystyle{plainurl}
\bibliography{bibliography}\textbf{}

\end{document}